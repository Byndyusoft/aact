# Anti-corruption Layer

## Контекст

Микросервисная архитектура с выделенными [мастер-системами](https://byndyusoft.com/blogs/masterdata), данные каждой из которых хранятся в отдельной БД

## Краткое описание решения и его обоснование
### Схема

### Решение

Выделение отдельных микросервисов, предоставляющих по API возможность CRUD-операций над данными. Доступ к каждой БД есть только у соответствующего CRUD-сервиса.

### Обоснование

Прямой доступ и всё разнообразие возможных операций (SQL-запросов) к БД должно быть ограничено стандартизованным API. Что позволяет избежать различные запросы на получение одних и тех же данных или выполнение схожих команд. Ограничение выполняемых SQL-запросов позволяет под них оптимизировать индексы и другие механизмы БД, что было бы менее эффективно при разнородных запросах от многих потребителей.
Отсутствие бизнес-логики в CRUD-сервисах позволяет соблюсти принципы Single Responsibility и Common Closure принципов, разделить логику от данных.

## Как покрыть тестами

1. Помечаем на архитектуре соответствующие микросервисы признаком "CRUD" (или Repository)
```
Container(task_repository, “Task Repository", "NestJS", $tags="crud")
```
2. Проверяем, что у таких сервисов нет исходящих связей, кроме единственной БД
```
Rel(task_repository, task_db, "") — ✅ т.к. исходящая связь в БД
Rel(camunda, task_repository, "") — ✅ т.к. входящая связь
Rel(task_repository, invoice_acl, "") — ❎ т.к. исходящая связь не в БД
```
3. Проверяем, что у БД нет никаких связей помимо единственной с crud-микросервисом
```
Rel(task_repository, task_db, "") — ✅ т.к. микросервис task_repository помечен тэгом "crud"
Rel(invoice_acl, task_db, "") — ❎ т.к. микросервис invoice_acl непомечен тэгом "crud"
Rel(invoice_repository, task_db, "") — ❎ т.к. выше уже есть одна связь у данной БД, хоть и invoice_repository помечен тэгом "crud"
```

### Примеры тестов

<TBD>